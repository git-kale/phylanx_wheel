## **Goals**
1. Package all the dependencies inside the wheel
2. Save the time that goes into building components
3. The process of wheel creation should be easily replicable
4. Packaging should work for a variety of Operating System

---

## **Problems**

1. PyPi doesn't have well-written specifications for creating extension wheel
2. Numerous ways of Packaging projects exist with respective pros and cons
3. Improper documentation of setuptools and distutils
4. The Phylanx package and its dependencies lack the support of static only build
5. Wheel packaging lacks the support of Pre and Post transactions
6. Wheel packaging lacks the support of symlink preservation
7. Unavailability of tools that can correct RPATHs of massive binaries
8. A large amount of time taken to build, repack, test and debug the wheel 

---

## **Possible approaches for the package**

Phylanx, along with its dependencies, already has a robust build system.

Build system generators like `scikit-build`, which provide better cross-system support are excellent. But changing the existing build system, which works fine for the creation of the wheel, would not be a good idea.

Projects like `auditwheel` that offer excellent support for Packaging binaries in the extension wheel are not worth diving straight into as they may lead to a dead end. 
The approach that auditwheel takes with handling binaries can be replicated manually on a recent toolchain.
Once we have a working wheel for a system the auditwheel approach can be taken.

There is one other way to build a pip package using `conda press`. This method requires you to have a conda package
beforehand.

---

## **Work**

The first step was to patch the Phylanx project to create a wheel instead of installing it in a specific location. The build system installs the dependencies before running the setup.py and creation of the wheel. Hence installing the wheel generated, the tests
run successfully, showing that the wheel runs if we have all dependencies in their correct place.

Now I needed to add the libraries to wheel package. There are no specifications on which directory structure to maintain while making a wheel package. Therefore I opted to go for NumPy library like structure involving a separate directory for all external dependencies. I was using the phylanx_base:prerequisites docker with all dependencies except BlazeTensor. Therefore, I focused on adding only HPX and Phylanx dependencies at first.

The next step would be to link these libraries. I spent some time checking how can RPATHs be set. Setting absolute RPATHs may leave an end-user with only the option to install a package at a specific location, which may fail when using a virtual environment. The program will work only from a particular directory after setting relative RPATHs. The best option would be to set up RPATH using a special symbol $ORIGIN since it helps to set up RPATH relative to the directory containing the library.

Trying to patch up files using patchelf gives an error :
````
maximum file size exceeded
````
This error is due to the hardcoded maximum limit on the size of libraries in the patchelf project. Some of the libraries don't have an RPATH, so the chrpath tool can't be used. The LIEF tool has some stability issues. Therefore, patching the patchelf was the only option. [https://github.com/pypa/auditwheel/issues/174]. After applying the patch, Patchelf can set RPATHs of libraries.

After setting up the libraries, the repacked wheel becomes installable. But running the most basic tests throws an error. The linker does not show any unfound libraries. The error was a segmentation fault showing the problem is with binaries and not with the wheel generated by the build system. Debugging the segmentation fault backtracks the error to HPX. Due to not having enough knowledge of how the HPX runtime works, Nikunj tried to pin down the issue and reported that it might be with HPX init. He suspected that the error might be because of static libraries. Therefore, I changed the setup.py and added the extra_objects field in setup to explicitly use the static libraries. But the error persisted even after this.

We did a side by side comparison of the current build system and the wheel installation and found out that the symlinks are getting replaced with the libraries. This issue is with the wheel packaging system. The wheel packaging uses a zipfile library that lacks the support of symlink preservation (as mentioned in problem 6). The wheel, which in turn is a 
zip file hence changes those symlinks at the time of repacking or unpacking. The shared library in the package has a 
dependency on these symlinks. Our thoughts were to run a post-transaction, which will create those symlinks, but as mentioned in problem 5, The wheel packaging system lacks this functionality. Copying the libraries also didn't work either. Therefore, we asked Prof. Hartmut what might be the reason for the behavior, and he recommended that we rename the binaries instead of copying them. And it worked! The downside of having these changes is the possibility
of having unnecessary copies of libraries, which affects the wheel package size.

Now for testing it on a system with no dependencies, I installed the file on a clean phylanx_base:prerequisites docker.
I got an error while running the test files. After running the debug session, I found out that the Phylanx plugins aren't getting loaded correctly. The issue was resolved after setting the PYTHON_PLUGIN_PATH environment variable to plugin directory.

For the next step, I packaged all the remaining dependencies of Phylanx within the package. The package is still in testing.

---

## **Current Work**


The package and build now pass the same tests. I'm currently working on replicating the process on other Operating Systems. I'm also working on the integration of the wheel creation process in Phylanx CI. A CI integration will allow the creation of a wheel as soon as the code is updated.

----
## **Future Work**

Trying the auditwheel approach would be the next step. Once I have a wheel for all Linux Based Operating systems. I can work on a wheel that can be installed on Windows. I will be trying Conda Press, which promises to solve the issues of packaging wheels by converting a conda package to a wheel. But due to the unnecessary work of writing a conda package, this approach will be tried at the end.

